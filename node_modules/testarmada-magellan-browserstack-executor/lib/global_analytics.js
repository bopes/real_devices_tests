"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _lodash = require("lodash");

var _lodash2 = _interopRequireDefault(_lodash);

var _events = require("events");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var timeline = [];
var _emitter = new _events.EventEmitter();

/* istanbul ignore next */
exports.default = {
  // Push a global (i.e. not testrun related) analytics event to the timeline.
  // This will cause any reporters that listen to global analytics events to
  // receive the event. A markers list will be started with the current time.
  //
  // NOTE: name must be unique if non-colliding markers are desired.
  push: function push(eventName, metadata, startMarkerName) {
    startMarkerName = startMarkerName ? startMarkerName : "start";

    var ev = {
      type: "analytics-event",
      data: {
        name: eventName,

        markers: [{
          name: startMarkerName,
          t: Date.now()
        }],

        metadata: metadata
      }
    };

    _emitter.emit("message", ev);
    timeline.push(ev);
  },

  // Mark an event's timeline with a marker named markerName at current time.
  // Default to a marker name of "end" if one isn't supplied.
  mark: function mark(eventName, markerName) {
    markerName = markerName ? markerName : "end";

    var ev = {
      type: "analytics-event-mark",
      eventName: eventName,
      data: {
        name: markerName,
        t: Date.now()
      }
    };

    _emitter.emit("message", ev);
    timeline.push(ev);
  },

  // Return a copy of the existing timeline so that late-arriving reporters
  // can synchronize to global analytics messages that emitted before they
  // were initialized.
  sync: function sync() {
    return _lodash2.default.cloneDeep(timeline);
  },

  getEmitter: function getEmitter() {
    return _emitter;
  }
};
//# sourceMappingURL=global_analytics.js.map