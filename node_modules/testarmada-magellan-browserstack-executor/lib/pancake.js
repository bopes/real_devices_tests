"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _lodash = require("lodash");

var _lodash2 = _interopRequireDefault(_lodash);

var _request = require("request");

var _request2 = _interopRequireDefault(_request);

var _cliTable = require("cli-table");

var _cliTable2 = _interopRequireDefault(_cliTable);

var _cliColor = require("cli-color");

var _cliColor2 = _interopRequireDefault(_cliColor);

var _testarmadaLogger = require("testarmada-logger");

var _testarmadaLogger2 = _interopRequireDefault(_testarmadaLogger);

var _configuration = require("./configuration");

var _configuration2 = _interopRequireDefault(_configuration);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var BROWSERSTACK_API_URL = "https://www.browserstack.com/automate/browsers.json";
var browserCache = {};

exports.default = {
  initialize: function initialize() {
    var ignoreCache = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    var argvMock = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var envMock = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    _testarmadaLogger2.default.prefix = "Browserstack Executor";
    var self = this;
    var config = null;

    return new Promise(function (resolve, reject) {
      if (!ignoreCache && _lodash2.default.keys(browserCache).length > 0) {
        resolve(browserCache);
      } else {
        try {
          config = _configuration2.default.validateConfig({}, argvMock, envMock);
        } catch (e) {
          reject(e);
        }
        var options = {
          "auth": {
            "user": config.user,
            "pass": config.key,
            "sendImmediately": false
          }
        };

        _request2.default.get(BROWSERSTACK_API_URL, options, function (err, response, body) {
          if (err) {
            reject(err);
          }

          self._buildBrowserCache(JSON.parse(body));
          resolve(browserCache);
        });
      }
    });
  },
  get: function get(id) {
    if (_lodash2.default.keys(browserCache).length > 0) {
      return browserCache[id];
    }

    return null;
  },
  cliList: function cliList() {
    _testarmadaLogger2.default.prefix = "Browserstack Executor";
    var self = this;

    if (_lodash2.default.keys(browserCache).length > 0) {
      _testarmadaLogger2.default.loghelp("Available Browserstack Browsers:");

      var families = _lodash2.default.groupBy(browserCache, function (capabilities) {
        return capabilities.browser;
      });
      var table = new _cliTable2.default({
        head: ["Family", "Alias", "Browser/Env", "Version", "OS", "OS Version", "Device"]
      });

      var count = 1;

      Object.keys(families).sort().forEach(function (family) {
        table.push([_cliColor2.default.red(_lodash2.default.capitalize(family))]);
        var currentFamily = families[family];

        _lodash2.default.forEach(currentFamily, function (capabilities) {
          var key = self._generateKey(capabilities);
          table.push([_cliColor2.default.blackBright(count + "."), key, _lodash2.default.capitalize(capabilities.browser), capabilities.browser_version ? capabilities.browser_version : "N/A", _lodash2.default.capitalize(capabilities.os), capabilities.os_version, capabilities.device ? capabilities.device : "N/A"]);
          count++;
        });
      });

      return table;
    }

    return null;
  },
  _generateKey: function _generateKey(capabilities) {
    var values = [];

    values.push(capabilities.browser);

    if (capabilities.browser_version) {
      values.push(capabilities.browser_version);
    }

    values.push(capabilities.os);
    values.push(capabilities.os_version);

    if (capabilities.device) {
      values.push(capabilities.device);
    }

    var key = values.join("_").replace(/(\.|\s)/g, "_");
    return key;
  },
  _buildBrowserCache: function _buildBrowserCache(browserstackResponse) {
    var self = this;
    browserCache = {};

    _lodash2.default.forEach(browserstackResponse, function (capabilities) {
      var key = self._generateKey(capabilities);
      browserCache[key] = capabilities;
    });
  }
};
//# sourceMappingURL=pancake.js.map