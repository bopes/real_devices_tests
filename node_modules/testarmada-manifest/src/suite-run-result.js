/* eslint complexity: 0, max-params: 0, no-unused-vars: 0, max-statements: 0 */
"use strict";

const EventEmitter = require("events");
const MarkedContainer = require("./srr/marked-container");
const AttemptList = require("./srr/attempt-list");
const Worker = require("./srr/worker");
const Test = require("./srr/test");
const Reports = require("./srr/reports");

const utils = require("./srr/utils");
const marker = utils.marker;
const values = utils.values;
const totalTime = utils.totalTime;

class SuiteRunResult extends EventEmitter {
  constructor() {
    super();

    this.suitePassed = null;
    this.startTime = null;
    this.totalTime = null;

    this.previousBusy = null;
    this.totalBusyTime = 0;
    this.previousIdle = null;
    this.totalIdleTime = 0;

    this.sauceLauncherFailed = null;
    this.sauceOpenTunnelsFailed = null;

    this.workers = {};
    this.testsByName = {};
  }

  get reports() {
    return new Reports(this.tests);
  }

  get testsByNameReport() {
    const flattendTests = {};
    for (const k in this.testsByName) {
      flattendTests[k] = {};
      for (const e in this.testsByName[k].environments) {
        flattendTests[k][e] = this.testsByName[k].environments[e].attempts;
      }
    }
    return this._report(flattendTests);
  }

  get tests() {
    return values(this.testsByName);
  }

  get testsByEnvironment() {
    const envs = {};
    for (const test of this.tests) {
      for (const env in test.environments) {
        if (envs[env] === undefined) {
          envs[env] = [];
        }
        for (const att of test.environments[env].attempts) {
          envs[env].push(att);
        }
      }
    }
    return envs;
  }

  get testsByEnvironmentAndTest() {
    const envs = {};
    for (const test of this.tests) {
      for (const env in test.environments) {
        if (envs[env] === undefined) {
          envs[env] = {};
        }
        envs[env][test.name] = test.environments[env].attempts;
      }
    }
    return envs;
  }

  get testsByEnvironmentReport() {
    return this._report(this.testsByEnvironmentAndTest);
  }

  get passed() {
    return this.tests.reduce((cur, test) => {
      return cur + (test.passed ? 1 : 0);
    }, 0);
  }

  get failed() {
    return this.tests.reduce((cur, test) => {
      return cur + (test.passed ? 0 : 1);
    }, 0);
  }

  get retried() {
    return this.tests.reduce((cur, test) => {
      return cur + test.retried;
    }, 0);
  }

  get testRuns() {
    return this.tests.reduce((arr, test) => {
      for (const tr of test.testRuns) {
        arr.push(tr);
      }
      return arr;
    }, []);
  }

  get timePassing() {
    return totalTime(this.testRuns.filter((tr) => tr.passed));
  }

  get timeFailing() {
    return totalTime(this.testRuns.filter((tr) => !tr.passed));
  }

  get timeRetrying() {
    return this.tests.reduce((cur, test) => {
      return cur + test.timeRetrying;
    }, 0);
  }

  get satisfiedWorkers() {
    return values(this.workers).filter((w) => w.satisfied);
  }

  get satisfiedWorkersTime() {
    return totalTime(this.satisfiedWorkers);
  }

  get unsatisfiedWorkers() {
    return values(this.workers).filter((w) => !w.satisfied);
  }

  get unsatisfiedWorkersTime() {
    return totalTime(this.unsatisfiedWorkers);
  }

  testsByTag(tag) {
    return this.tests.filter((test) => test.hasTag(tag));
  }

  passedByTag(tag) {
    return this.testsByTag(tag).filter((test) => test.passed).length;
  }

  failedByTag(tag) {
    return this.testsByTag(tag).filter((test) => !test.passed).length;
  }

  timeElapsedByTag(tag) {
    return this.testsByTag(tag).reduce((cur, test) => cur + test.timeElapsed, 0);
  }

  setTags(test, tags) {
    if (this.testsByName[test]) {
      this.testsByName[test].tags = tags;
    }
  }

  // Event distribution
  globalMessage(message) {
    if (message.type === "analytics-event") {
      if (message.data === undefined || message.data.name === undefined) {
        this.onUnknownGlobalMessage(message);
        return;
      }
      if (message.data.name === "magellan-run") {
        if (message.data.markers[0].name === "start") {
          this.onMagellanStart(message, marker(message).t);
        }
      } else if (message.data.name === "magellan-busy") {
        if (message.data.markers[0].name === "idle") {
          this.onMagellanIdle(message, marker(message).t);
        }
        if (message.data.markers[0].name === "busy") {
          this.onMagellanBusy(message, marker(message).t);
        }
      } else if (message.data.name === "sauce-connect-launcher-download") {
        this.onSauceConnectLauncherDownload(message, message.data.markers[0].name === "failed");
      } else if (message.data.name === "sauce-open-tunnels") {
        this.onSauceOpenTunnels(message, message.data.markers[0].name === "failed");
      } else if (message.data.name.match(/^acquire-worker-/)) {
        this.onAcquireWorker(message,
          message.data.name.match(/^acquire-worker-(.*?)$/)[1],
          marker(message).t,
          message.data.markers[0].name);
      } else {
        this.onUnknownGlobalMessage(message);
      }
    } else if (message.type === "analytics-event-mark") {
      if (message.eventName === undefined) {
        this.onUnknownGlobalMessage(message);
        return;
      }
      if (message.eventName === "magellan-run") {
        if (message.data.name === "passed") {
          this.onMagellanPassed(message, marker(message).t);
        } else if (message.data.name === "failed") {
          this.onMagellanFailed(message, marker(message).t);
        }
      } else if (message.eventName === "magellan-busy") {
        if (message.data.name === "idle") {
          this.onMagellanIdle(message, marker(message).t);
        }
        if (message.data.name === "busy") {
          this.onMagellanBusy(message, marker(message).t);
        }
      } else if (message.eventName === "sauce-connect-launcher-download") {
        this.onSauceConnectLauncherDownload(message, message.data.name === "failed");
      } else if (message.eventName === "sauce-open-tunnels") {
        this.onSauceOpenTunnels(message, message.data.name === "failed");
      } else if (message.eventName.match(/^acquire-worker-/)) {
        this.onAcquireWorker(message,
          message.eventName.match(/^acquire-worker-(.*?)$/)[1],
          marker(message).t,
          message.data.name);
      } else {
        this.onUnknownGlobalMessage(message);
      }
    } else {
      this.onUnknownGlobalMessage(message);
    }
  }

  testRunMessage(testRun, test, message) {
    if (test === undefined ||
      test.locator === undefined || test.locator.filename === undefined ||
      test.attempts === undefined ||
      message.type === undefined ||
      (test.profile === undefined || test.profile.id === undefined) &&
      (test.browser === undefined || test.browser.browserId === undefined)
    ) {
      this.onUnknownTestRunMessage(testRun, test, message);
      return;
    }

    if (this.testsByName[test.locator.filename] === undefined) {
      this.testsByName[test.locator.filename] = new Test(test.locator.filename);
      this.emit("newTest", this.testsByName[test.locator.filename]);
    }

    let env = null;

    if (test.browser && test.browser.browserId) {
      env = test.browser.browserId;
    } else {
      // no need to check test.profile === undefined as it is already checked above
      env = test.profile.id;
    }

    const tr = this.testsByName[test.locator.filename].getTestRun(
      env, test.attempts
    );

    if (message.type === "analytics-event-mark") {
      tr.addMarker(marker(message));
    } else if (message.type === "analytics-event") {
      for (const mkr of message.data.markers) {
        tr.addMarker(mkr);
      }
    } else if (message.type === "worker-status") {
      tr.status = message.status;
      if (message.status === "started") {
        this.emit("testRunStart", tr);
      } else if (message.status === "finished") {
        tr.passed = message.passed;
        tr.metadata = message.metadata;
        this.emit("testRunEnd", tr);
      } else {
        this.onUnknownTestRunMessage(testRun, test, message);
      }
    } else {
      this.onUnknownTestRunMessage(testRun, test, message);
    }
  }

  // Event handlers
  onMagellanStart(message, time) {
    this.startTime = time;
    this.emit("start");
  }

  onMagellanPassed(message, time) {
    this.totalTime = time - this.startTime;
    this.suitePassed = true;
    this.emit("end");
  }

  onMagellanFailed(message, time) {
    this.totalTime = time - this.startTime;
    this.suitePassed = false;
    this.emit("end");
  }

  onMagellanBusy(message, time) {
    if (this.previousIdle) {
      this.emit("magellanIdle", time - this.previousIdle);
    }
    if (this.previousBusy) {
      this.totalBusyTime += time - this.previousBusy;
    }
    this.previousBusy = time;
    this.previousIdle = null;
  }

  onMagellanIdle(message, time) {
    if (this.previousBusy) {
      this.emit("magellanBusy", time - this.previousBusy);
    }
    if (this.previousIdle) {
      this.totalIdleTime += time - this.previousIdle;
    }
    this.previousBusy = null;
    this.previousIdle = time;
  }

  onSauceConnectLauncherDownload(message, failed) {
    this.sauceLauncherFailed = failed;
  }

  onSauceOpenTunnels(message, failed) {
    this.sauceOpenTunnelsFailed = failed;
  }

  onAcquireWorker(message, worker, time, state) {
    if (this.workers[worker] === undefined) {
      this.workers[worker] = new Worker(worker);
    }
    this.workers[worker].state = state;
    this.workers[worker].addMarker(marker(message));
    this.emit("workerStatus", this.workers[worker], state, time);
  }

  onUnknownGlobalMessage(message) {
    this.emit("unknownGlobalMessage", message);
  }

  onUnknownTestRunMessage(testRun, test, message) {
    this.emit("onUnknownTestRunMessage", testRun, test, message);
  }

  _report(keyedList) {
    const out = {};
    const _generateReport = (trList) => {
      let passed = 0;
      let finallyPassed = 0;
      let failed = 0;
      let retries = 0;
      let passedRetries = 0;
      for (const k in trList) {
        const atts = new AttemptList(trList[k]);
        passed += atts.passed ? 1 : 0;
        failed += atts.failed ? 1 : 0;
        finallyPassed += atts.passed && atts.retries > 0 ? 1 : 0;
        passedRetries += atts.passed ? atts.retries : 0;
        retries += atts.retries;
      }

      return {
        passed,
        finallyPassed,
        failed,
        passedRetries,
        retries
      };
    };
    for (const k in keyedList) {
      out[k] = _generateReport(keyedList[k]);
    }
    return out;
  }
}

module.exports = SuiteRunResult;
