"use strict";

const utils = require("./utils");

const _sortBy = (arr, vf) => arr.sort((a, b) => {
  const af = vf(a);
  const bf = vf(b);
  if (af < bf) {
    return -1;
  } else if (af > bf) {
    return 1;
  } else {
    return 0;
  }
});
const _onlyPassed = (arr) => arr.filter((t) => t.passed);
const _top = (a, amt) => a.slice(0, Math.min(Math.ceil(a.length / 2), amt || 10));
const _bottom = (a, amt) => a.slice(a.length - Math.min(Math.floor(a.length / 2), amt || 10));
const _valuesForKey = (a, k) => a.map((obj) => obj[k]);
const _min = (a) => Math.min.apply(null, a);
const _max = (a) => Math.max.apply(null, a);

class Reports {
  constructor(tests) {
    const testsByTimeElapsed = _sortBy(_onlyPassed(tests), (t) => t.timeElapsed);
    const timeElapsedValues = _valuesForKey(_onlyPassed(tests), "timeElapsed");

    this.timeElapsed = {
      top: _top(testsByTimeElapsed),
      bottom: _bottom(testsByTimeElapsed),
      complete: testsByTimeElapsed,
      average: utils.average(timeElapsedValues),
      stddev: utils.stddev(timeElapsedValues)
    };

    const testsByTimeForPassed = _sortBy(_onlyPassed(tests), (t) => t.timeForPassed);
    const timeForPassedValues = _valuesForKey(_onlyPassed(tests), "timeForPassed");

    this.timeForPassed = {
      top: _top(testsByTimeForPassed),
      bottom: _bottom(testsByTimeForPassed),
      complete: testsByTimeForPassed,
      average: utils.average(timeForPassedValues),
      stddev: utils.stddev(timeForPassedValues)
    };

    const envsByEnvironment = {};
    tests.forEach((test) => {
      Object.keys(test.environments).forEach((env) => {
        if (test.environments[env].passed) {
          if (envsByEnvironment[env] === undefined) {
            envsByEnvironment[env] = [];
          }
          envsByEnvironment[env].push(test.environments[env]);
        }
      });
    });

    this.byEnvironment = {};
    Object.keys(envsByEnvironment).forEach((env) => {
      if (envsByEnvironment[env].length > 0) {
        const envTimeForPassed = _valuesForKey(envsByEnvironment[env], "timeForPassed");
        const totalRetries = envsByEnvironment[env].reduce((c, e) => c + e.retries.length, 0);
        this.byEnvironment[env] = {
          min: _min(envTimeForPassed),
          max: _max(envTimeForPassed),
          average: utils.average(envTimeForPassed),
          stddev: utils.stddev(envTimeForPassed),
          avgRetries: totalRetries / envsByEnvironment[env].length
        };
      }
    });
  }
}

module.exports = Reports;
