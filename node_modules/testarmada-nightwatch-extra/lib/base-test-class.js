"use strict";

var _lodash = require("lodash");

var _lodash2 = _interopRequireDefault(_lodash);

var _settings = require("./settings");

var _settings2 = _interopRequireDefault(_settings);

var _magellan = require("./worker/magellan");

var _magellan2 = _interopRequireDefault(_magellan);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var BaseTest = function BaseTest(steps) {
  var customizedSettings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  /**
   * NOTICE: we don't encourage to pass [before, beforeEach, afterEach, after]
   *         together with steps into the constructor. PLEASE extend the base test
   *         and define these four methods there if they are necessary
   */
  var self = this;
  var enumerables = ["before", "after", "beforeEach", "afterEach"];

  this.isWorker = _settings2.default.isWorker;
  this.env = _settings2.default.env;

  if (customizedSettings) {
    this.isWorker = customizedSettings.isWorker;
    this.env = customizedSettings.env;
  }

  // copy steps to self
  _lodash2.default.forEach(steps, function (v, k) {
    Object.defineProperty(self, k, { enumerable: true, value: v });
  });

  // copy before, beforeEach, afterEach, after to prototype
  _lodash2.default.forEach(enumerables, function (k) {
    var srcFn = self[k] || BaseTest.prototype[k];
    if (srcFn) {
      Object.defineProperty(self, k, { enumerable: true, value: srcFn });
    }
  });
};

BaseTest.prototype = {
  /*eslint-disable callback-return*/
  before: function before(client, callback) {
    this.failures = [];
    this.passed = 0;

    // we only want timeoutsAsyncScript to be set once the whole session to limit
    // the number of http requests we sent
    this.isAsyncTimeoutSet = false;
    this.isSupposedToFailInBefore = false;

    if (this.isWorker) {
      this.worker = new _magellan2.default({ nightwatch: client });
      process.addListener("message", this.worker.handleMessage);
    }
    callback();
  },
  beforeEach: function beforeEach(client) {
    if (!this.isAsyncTimeoutSet) {
      client.timeoutsAsyncScript(_settings2.default.JS_MAX_TIMEOUT);
      this.isAsyncTimeoutSet = true;
    }

    // Note: Sometimes, the session hasn't been established yet but we have control.
    if (client.sessionId) {
      _settings2.default.sessionId = client.sessionId;

      if (this.isWorker) {
        this.worker.emitMetadata({
          sessionId: _settings2.default.sessionId,
          capabilities: client.capabilities
        });
      }
    }
  },
  afterEach: function afterEach(client, callback) {
    if (this.results) {
      // in case we failed in `before`
      // keep track of failed tests for reporting purposes
      if (this.results.failed || this.results.errors) {
        // Note: this.client.currentTest.name is also available to display
        // the name of the specific step within the test where we've failed.
        this.failures.push(client.currentTest.module);
      }

      if (this.results.passed) {
        this.passed += this.results.passed;
      }
    }

    if (!this.isAsyncTimeoutSet) {
      client.timeoutsAsyncScript(_settings2.default.JS_MAX_TIMEOUT);
      this.isAsyncTimeoutSet = true;
    }

    // Note: Sometimes, the session hasn't been established yet but we have control.
    if (client.sessionId) {
      _settings2.default.sessionId = client.sessionId;

      if (this.isWorker) {
        this.worker.emitMetadata({
          sessionId: _settings2.default.sessionId,
          capabilities: client.capabilities
        });
      }
    }

    callback();
  },


  /*eslint-disable callback-return*/
  after: function after(client, callback) {
    var self = this;

    if (this.isWorker) {
      process.removeListener("message", self.worker.handleMessage);
    }

    if (self.isSupposedToFailInBefore) {
      // there is a bug in nightwatch that if test fails in `before`, test
      // would still be reported as passed with a exit code = 0. We'll have
      // to let magellan know the test fails in this way
      /* istanbul ignore next */
      /*eslint no-process-exit:0 */
      /*eslint no-magic-numbers:0 */
      process.exit(100);
    }
    // executor should eat it's own error in summerize()

    client.end();
    callback();
  }
};

module.exports = BaseTest;
//# sourceMappingURL=base-test-class.js.map