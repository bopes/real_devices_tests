"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _events = require("events");

var _events2 = _interopRequireDefault(_events);

var _util = require("util");

var _util2 = _interopRequireDefault(_util);

var _settings = require("./settings");

var _settings2 = _interopRequireDefault(_settings);

var _errorDictionary = require("./errorDictionary");

var _errorDictionary2 = _interopRequireDefault(_errorDictionary);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Wait until we've seen a selector as :visible SEEN_MAX times, with a
// wait for WAIT_INTERVAL milliseconds between each visibility test.
var MAX_TIMEOUT = _settings2.default.COMMAND_MAX_TIMEOUT;
var WAIT_INTERVAL = _settings2.default.WAIT_INTERVAL;
var SEEN_MAX = _settings2.default.MOBILE_SEEN_MAX;

var Base = function Base() {
  var nightwatch = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

  _events2.default.call(this);

  this.startTime = 0;
  this.time = {
    totalTime: 0,
    seleniumCallTime: 0,
    executeAsyncTime: 0
  };

  this.selector = null;

  this.successMessage = "";
  this.failureMessage = "";

  this.checkConditions = this.checkConditions.bind(this);
  // for mock and unit test
  if (nightwatch) {
    this.client = nightwatch;
  }

  if (this.client && this.client.queue && _typeof(this.client.queue.instance === 'function')) {
    var instance = this.client.queue.instance();
    if (instance && instance.currentNode) {
      this.stackTrace = instance.currentNode.stackTrace;
    }
  }
};

_util2.default.inherits(Base, _events2.default);

Base.prototype.protocol = function (options, cb) {
  this.client.runProtocolAction(options, cb).send();
};

Base.prototype.checkConditions = function () {
  var self = this;

  var options = {
    path: "/session/" + this.client.sessionId + "/element",
    method: "POST",
    data: {
      using: this.using,
      value: this.selector
    }
  };

  self.protocol(options, function (result) {
    if (result.status === 0) {
      // sucessful
      self.seenCount += 1;
    }

    var elapsed = new Date().getTime() - self.startTime;

    if (self.seenCount >= SEEN_MAX || elapsed > MAX_TIMEOUT) {
      if (self.seenCount >= SEEN_MAX) {
        var elapse = new Date().getTime();
        self.time.executeAsyncTime = elapse - self.startTime;
        self.time.seleniumCallTime = 0;

        self.do(result.value);
      } else {
        var errorMsg = null;
        var actual = null;
        var expected = null;
        if (result.error) {
          if (result.error.indexOf("could not be located") > -1) {
            errorMsg = self.message + "[SELECTOR_NOT_FOUND]";
            actual = "[not found]";
            expected = "[found]";
          } else if (result.error.indexOf("not visible") > -1) {
            errorMsg = self.message + "[SELECTOR_NOT_VISIBLE]";
            actual = "[not visible]";
            expected = "[visible]";
          } else {
            errorMsg = self.message + "[" + result.error + "]";
          }
        }
        self.fail(actual, expected, errorMsg);
      }
    } else {
      setTimeout(self.checkConditions, WAIT_INTERVAL);
    }
  });
};

Base.prototype.pass = function (actual, expected, message) {
  this.time.totalTime = new Date().getTime() - this.startTime;

  this.client.assertion(true, actual, expected, _util2.default.format(this.message, this.time.totalTime), true);
  this.emit("complete");
};

/*eslint max-params:["error", 4] */
Base.prototype.fail = function (actual, expected, message, detail) {
  var pactual = actual || "not visible";
  var pexpected = expected || "visible";
  this.time.totalTime = new Date().getTime() - this.startTime;
  var fmtmessage = _errorDictionary2.default.format(_util2.default.format((this.isSync ? "[sync mode] " : "") + (message || this.message), this.time.totalTime));

  this.client.assertion(false, pactual, pexpected, fmtmessage, true, this.stackTrace);
  this.emit("complete");
};

/**
 * All children have to implement do
 *
 */
/* istanbul ignore next */
/*eslint no-unused-vars:0 */
Base.prototype.assert = function (actual, expected) {};

/**
 * All children have to implement do
 *
 */
/* istanbul ignore next */
/*eslint no-unused-vars:0 */
Base.prototype.do = function (value) {};

/**
 * All children have to implement command
 *
 */
/* istanbul ignore next */
/*eslint no-unused-vars:0 */
Base.prototype.command = function (using, selector, expected, cb) {
  return this;
};

module.exports = Base;
//# sourceMappingURL=base-mobile-assertion.js.map