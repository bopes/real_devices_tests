"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _events = require("events");

var _events2 = _interopRequireDefault(_events);

var _util = require("util");

var _util2 = _interopRequireDefault(_util);

var _lodash = require("lodash");

var _lodash2 = _interopRequireDefault(_lodash);

var _cliColor = require("cli-color");

var _cliColor2 = _interopRequireDefault(_cliColor);

var _jsonStringifySafe = require("json-stringify-safe");

var _jsonStringifySafe2 = _interopRequireDefault(_jsonStringifySafe);

var _settings = require("./settings");

var _settings2 = _interopRequireDefault(_settings);

var _selector = require("./util/selector");

var _selector2 = _interopRequireDefault(_selector);

var _jsInjection = require("./injections/js-injection");

var _jsInjection2 = _interopRequireDefault(_jsInjection);

var _stats = require("./util/stats");

var _stats2 = _interopRequireDefault(_stats);

var _logger = require("./util/logger");

var _logger2 = _interopRequireDefault(_logger);

var _errorDictionary = require("./errorDictionary");

var _errorDictionary2 = _interopRequireDefault(_errorDictionary);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Wait until we've seen a selector as :visible SEEN_MAX times, with a
// wait for WAIT_INTERVAL milliseconds between each visibility test.
var MAX_TIMEOUT = _settings2.default.COMMAND_MAX_TIMEOUT;
var WAIT_INTERVAL = _settings2.default.WAIT_INTERVAL;
var SEEN_MAX = _settings2.default.SEEN_MAX;
var JS_SEEN_MAX = _settings2.default.JS_SEEN_MAX;

var Base = function Base() {
  var nightwatch = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var customizedSettings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  _events2.default.call(this);

  this.isSync = false;
  this.startTime = 0;
  this.time = {
    totalTime: 0,
    seleniumCallTime: 0,
    executeAsyncTime: 0
  };

  this.selectorPrefix = "data-magellan-temp-automation-id";
  this.selector = null;

  this.successMessage = "";
  this.failureMessage = "";

  this.checkConditions = this.checkConditions.bind(this);
  this.syncModeBrowserList = _settings2.default.syncModeBrowserList;

  // for mock and unit test
  if (nightwatch) {
    this.client = nightwatch;
  }
  if (customizedSettings) {
    this.syncModeBrowserList = customizedSettings.syncModeBrowserList;
  }

  if (this.client && this.client.queue && _typeof(this.client.queue.instance === 'function')) {
    var instance = this.client.queue.instance();
    if (instance && instance.currentNode) {
      this.stackTrace = instance.currentNode.stackTrace;
    }
  }
};

_util2.default.inherits(Base, _events2.default);

Base.prototype.decide = function () {
  var self = this;

  this.nightwatchExecute = this.client.api.executeAsync;
  this.executeSizzlejs = _jsInjection2.default.executeSizzlejsAsync;

  var exam = function exam(b, v, desiredCapabilities) {
    if (v) {
      if (desiredCapabilities.browser && parseInt(desiredCapabilities.browser_version) === parseInt(v) && desiredCapabilities.browser.toLowerCase() === b) {
        return true;
      } else if (desiredCapabilities.browserName && parseInt(desiredCapabilities.version) === parseInt(v) && desiredCapabilities.browserName.toLowerCase() === b) {
        return true;
      }
    } else {
      /* eslint-disable  no-lonely-if */
      if (desiredCapabilities.browser && desiredCapabilities.browser.toLowerCase() === b) {
        return true;
      } else if (desiredCapabilities.browserName && desiredCapabilities.browserName.toLowerCase() === b) {
        return true;
      }
    }

    return false;
  };

  _lodash2.default.forEach(this.syncModeBrowserList, function (browser) {
    var b = null;
    var v = null;
    var cap = browser.split(":");
    b = cap[0];
    if (cap.length > 1) {
      v = cap[1];
    }

    if (exam(b, v, self.client.desiredCapabilities)) {
      self.isSync = true;
      self.nightwatchExecute = self.client.api.execute;
      self.executeSizzlejs = _jsInjection2.default.executeSizzlejsSync;
    }
  });
};

Base.prototype.checkConditions = function () {
  var self = this;

  this.execute(this.executeSizzlejs, [this.selector, this.injectedJsCommand()], function (result) {
    // Keep a running count of how many times we've seen this element visible
    if (result.isVisible) {
      self.seenCount += 1;
    }

    var elapsed = new Date().getTime() - self.startTime;

    // If we've seen the selector enough times or waited too long, then
    // it's time to pass or fail and continue the command chain.
    if (result.seens >= JS_SEEN_MAX || self.seenCount >= SEEN_MAX || elapsed > MAX_TIMEOUT) {

      // Unlike clickEl, only issue a warning in the getEl() version of this
      if (result.selectorLength > 1) {
        _logger2.default.warn("getEl saw selector " + self.selector + " but result length was " + (" " + result.selectorLength + ", with " + result.selectorVisibleLength + " of those :visible"));
        _logger2.default.warn("Selector did not disambiguate after " + elapsed + " milliseconds, " + "refine your selector or check DOM for problems.");
      }

      if (self.seenCount >= SEEN_MAX || result.seens >= JS_SEEN_MAX) {

        var elapse = new Date().getTime();
        self.time.executeAsyncTime = elapse - self.startTime;
        self.time.seleniumCallTime = 0;
        self.assert(result.value.value, self.expected);
      } else {
        if (result.selectorLength === 1) {
          self.fail("[not visible]", self.expected, self.message + "[SELECTOR_NOT_VISIBLE]");
        } else {
          self.client.api.title(function (title) {
            if (title.value === 'Bad Gateway' || title.value === 'Can\'t reach this page') {
              self.fail("[bad gateway]", self.expected, self.message + "[BAD_GATEWAY]");
            } else {
              self.fail("[not found]", self.expected, self.message + "[SELECTOR_NOT_FOUND ]");
            }
          });
        }
      }
    } else {
      setTimeout(self.checkConditions, WAIT_INTERVAL);
    }
  });
};

Base.prototype.execute = function (fn, args, callback) {
  var _this = this;

  var self = this;

  var innerArgs = _lodash2.default.cloneDeep(args);
  var selector = _selector2.default.depageobjectize(innerArgs.shift(), this.client.locateStrategy);

  innerArgs.unshift(selector);
  innerArgs.push(_jsInjection2.default.getSizzlejsSource());
  innerArgs.push(_settings2.default.JS_WAIT_INTERNAL);
  innerArgs.push(_settings2.default.JS_SEEN_MAX);

  this.nightwatchExecute(fn, innerArgs, function (result) {
    if (_settings2.default.verbose) {
      _logger2.default.log("execute(" + innerArgs + ") intermediate result: " + JSON.stringify(result));
    }
    /*eslint no-magic-numbers:0 */
    if (result && result.status === 0 && result.value !== null) {
      // Note: by checking the result and passing result.value to the callback,
      // we are claiming that the result sent to the callback will always be truthy
      // and useful, relieving the callback from needing to check the structural
      // validity of result or result.value

      callback.call(self, result.value);
    } else if (result && result.status === -1 && result.errorStatus === 13 && result.value !== null) {
      // errorStatus = 13: javascript error: document unloaded while waiting for result
      // we want to reload the page
      callback.call(self, {
        seens: 0,
        jsDuration: 0,
        jsStepDuration: [],
        isResultReset: true,
        isVisibleStrict: null,
        isVisible: false,
        selectorVisibleLength: 0,
        selectorLength: 0,
        value: {
          sel: null,
          value: null
        }
      });
    } else {
      _logger2.default.warn(_cliColor2.default.yellowBright("\u2622  Received error result from Selenium. " + "Raw Selenium result object:"));
      var resultDisplay = void 0;
      try {
        resultDisplay = (0, _jsonStringifySafe2.default)(result);
      } catch (e) {
        resultDisplay = _util2.default.inspect(result, false, null);
      }
      _logger2.default.warn(_cliColor2.default.yellowBright(resultDisplay));
      self.fail("[selenium error]", _this.expected, resultDisplay + "[SELENIUM_ERROR]");
    }
  });
};

Base.prototype.pass = function (actual, expected, message) {
  this.time.totalTime = new Date().getTime() - this.startTime;
  var fmtmessage = (this.isSync ? "[sync mode] " : "") + this.message;

  this.client.assertion(true, actual, expected, _util2.default.format(fmtmessage, this.time.totalTime), true);

  (0, _stats2.default)({
    capabilities: this.client.options.desiredCapabilities,
    type: "command",
    cmd: this.cmd,
    value: this.time
  });

  this.emit("complete");
};

/*eslint max-params:["error", 4] */
Base.prototype.fail = function (actual, expected, message, detail) {
  this.time.totalTime = new Date().getTime() - this.startTime;
  var fmtmessage = _errorDictionary2.default.format(_util2.default.format((this.isSync ? "[sync mode] " : "") + (message || this.message), this.time.totalTime));
  this.client.assertion(false, actual, expected, fmtmessage, true, this.stackTrace);
  this.emit("complete");
};

/**
 * All children have to implement injectedJsCommand
 *
 */
/* istanbul ignore next */
/*eslint no-unused-vars:0 */
Base.prototype.injectedJsCommand = function ($el) {
  return "";
};

/**
 * All children have to implement do
 *
 */
/* istanbul ignore next */
/*eslint no-unused-vars:0 */
Base.prototype.assert = function (actual, expected) {};

/**
 * All children have to implement command
 *
 */
/* istanbul ignore next */
/*eslint no-unused-vars:0 */
Base.prototype.command = function (selector, expected, cb) {
  return this;
};

module.exports = Base;
//# sourceMappingURL=base-assertion.js.map