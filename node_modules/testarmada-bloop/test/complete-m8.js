/* eslint import/no-extraneous-dependencies: 0, no-undef: 0,
  guard-for-in: 0, prefer-const: 0, arrow-body-style: 0, no-restricted-syntax: 0, max-params: 0,
  max-statements: 0, no-unused-expressions: 0 */

"use strict";

const expect = require("chai").expect;
const completeData = require("./data/complete-data-m8");
const correctData = require("./data/correct-data");
const Reporter = require("../index");

const _runMessages = (rep) => {
  for (let message of completeData) {
    if (message.type === "global") {
      rep.handleGlobalMessage(message.message);
    } else {
      rep.handleTestRunMessage(message.testRun, message.test, message.message);
    }
  }
  rep.flush();
};

describe("complete for magellan@8", () => {
  it("check disabled", () => {
    const rep = new Reporter({
      enabled: false,
      jobName: null
    });
    _runMessages(rep);
  });

  it("check no job name", () => {
    const rep = new Reporter({
      enabled: true,
      jobName: null,
      debugging: true,
      logDirectory: ".",
      logger: () => {},
      fs: {
        writeFileSync: () => {}
      },
      getTags: () => []
    });
    _runMessages(rep);
  });

  it("check a big log", () => {
    const rep = new Reporter({
      enabled: true,
      jobName: null,
      debugging: true,
      logDirectory: ".",
      logger: () => {},
      fs: {
        writeFileSync: () => {}
      },
      getTags: () => []
    });
    rep.log = [];
    for (let i = 0; i < 600; i++) {
      rep.log.push(i);
    }
    rep._addToLog(1);
  });

  it("flush with mock ssr", () => {
    const rep = new Reporter({
      enabled: true,
      jobName: null,
      debugging: true,
      logDirectory: ".",
      logger: () => {},
      fs: {
        writeFileSync: () => {}
      },
      getTags: () => []
    });
    rep.srr = {
      satisfiedWorkers: [],
      unsatisfiedWorkers: [],
      setTags: () => {},
      testsByTag: () => [],
      reports: {
        timeElapsed: {
          top: [],
          bottom: [{
            name: "foo",
            timeElapsed: 10,
            timeForPassed: 20
          }]
        },
        timeForPassed: {
          top: [],
          bottom: []
        },
        byEnvironment: {}
      },
      totalIdleTime: 20,
      totalBusyTime: 30,
      passed: 0,
      retried: 2,
      failed: 1,
      totalTime: 15,
      testsByNameReport: {},
      testsByEnvironmentReport: {},
      tests: [
        {
          passed: false,
          environments: {
            chrome: {
              attempts: [1, 2, 3]
            }
          }
        },
        {
          passed: true,
          environments: {
            chrome: {
              attempts: [1, 2, 3]
            }
          }
        }
      ]
    };
    rep._flush();
  });

  it("simulate bad _flush", () => {
    let thrown = false;
    const rep = new Reporter({
      enabled: false,
      jobName: null
    });
    rep._flush = () => {
      throw new Error("foo");
    };
    try {
      rep.flush();
    } catch (e) {
      thrown = true;
    }
    expect(thrown).to.be.true;
  });

  it("check bad statsd", () => {
    const rep = new Reporter({
      enabled: true,
      jobName: null,
      debugging: true,
      logger: () => {},
      fs: {
        writeFileSync: () => {}
      },
      getTags: () => [],
      statsd: {
        timing: (key, val, tags, cb) => {
          cb("foo");
        },
        increment: (key, val, tags, cb) => {
          cb("foo");
        },
        gauge: (key, val, tags, cb) => {
          cb("foo");
        },
        close: (cb) => {
          cb("foo");
        }
      }
    });
    rep.listenTo(null, null, {addListener: () => {}});
    rep.listenTo("foo", null, {addListener: () => {}});
    rep.listenTo("foo", "baz", {addListener: (a, cb) => {
      expect(a).to.not.be.null;
      cb(null, null, null);
    }});
    _runMessages(rep);
  });

  it("should compare 100% to a complete run", () => {
    const statsdData = [];
    const rep = new Reporter({
      logger: () => {},
      jobName: "foo.bar.baz",
      enabled: true,
      getTags: () => [],
      sleepTime: 1,
      statsd: {
        timing: (key, val, tags, cb) => {
          statsdData.push({
            type: "timing",
            key,
            value: val,
            tags
          });
          cb(null);
        },
        increment: (key, val, tags, cb) => {
          statsdData.push({
            type: "increment",
            key,
            value: val,
            tags
          });
          cb(null);
        },
        gauge: (key, val, tags, cb) => {
          statsdData.push({
            type: "gauge",
            key,
            value: val,
            tags
          });
          cb(null);
        },
        close: (cb) => {
          statsdData.push({
            type: "close"
          });
          cb(null);
        }
      }
    });

    rep.initialize({
      analytics: {
        sync: () => [],
        getEmitter: () => {
          return {
            addListener: () => {}
          };
        }
      }
    });

    _runMessages(rep);

    expect(statsdData.length).to.eql(correctData.length);
    for (let i in statsdData) {
      // console.log(statsdData[i]);
      expect(statsdData[i]).to.eql(correctData[i]);
    }

    const reports = rep.srr.reports;
    expect(rep.srr.tests[0].timeElapsed).to.eql(9623);
    expect(rep.srr.tests[0].passed).to.eql(true);
    expect(rep.srr.tests[0].timeForPassed).to.eql(9623);
    expect(rep.srr.tests[0].environments).to.not.be.null;
    expect(rep.srr.tests[0].environments.chrome.timeElapsed).to.eql(9623);
    expect(rep.srr.tests[0].environments.chrome.timeForPassed).to.eql(9623);
    expect(reports.timeForPassed.average).to.eql(9623);
    expect(reports.byEnvironment.chrome.average).to.eql(9623);
  });
});
