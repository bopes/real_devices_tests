/* eslint no-console: 0, no-fallthrough: 0,
  max-statements: 0, no-extra-parens: 0, max-depth: 0, complexity: 0, max-params: 0,
  consistent-return: 0 */

"use strict";

const Q = require("q");
const argv = require("yargs").argv;
const SDC = require("hot-shots");
const fs = require("fs");
const async = require("async");
const SuiteRunResult = require("testarmada-manifest");
const _ = require("lodash");

const getTags = require("./src/get-tags");
const project = require("./package.json");
const buildType = require("./src/build-type");

const Reporter = function Reporter(options) {
  const opts = _.assign({
    logger: console.log,
    getTags,
    jobName: process.env.MAGELLAN_JOB_NAME,
    enabled: process.env.MAGELLAN_STATSD !== undefined &&
      /* istanbul ignore next */ process.env.MAGELLANSTATS_STATSD_URL !== undefined,
    debugging: process.env.MAGELLAN_STATSD_DEBUGGING !== undefined,
    logDirectory: process.env.MAGELLAN_LOG_DIRECTORY,
    fs
  }, options);
  this.fs = opts.fs;
  this.logger = opts.logger;
  this.getTags = opts.getTags;
  this.jobName = opts.jobName;
  this.enabled = opts.enabled;
  this.debugging = opts.debugging;

  this.logDirectory = opts.logDirectory;
  this.log = this.logDirectory ? [] : undefined;
  this.logIndex = 0;
  this.logDate = new Date();

  let statsD;

  if (this.enabled) {
    const statsdOptions = {
      telegraf: true,
      host: process.env.MAGELLANSTATS_STATSD_URL,
      port: process.env.MAGELLANSTATS_STATSD_PORT || 8125,
      prefix: `${(process.env.MAGELLANSTATS_STATSD_PREFIX || "magellanStatsdMetrics")}.`
    };

    this.logger(`Magellan Internal Stats Reporter v${project.version} is starting..`);
    /* istanbul ignore next */
    statsD = (options && options.statsd) ? options.statsd : new SDC(statsdOptions);
    this.logger("Magellan Internal Stats Reporter started StatsD client with options: ");
    this.logger(JSON.stringify(statsdOptions, null, 2));
    if (this.jobName) {
      this.logger(`Magellan Internal Stats Reporter sees a Magellan job name of: ${this.jobName}`);
    } else {
      this.logger(
        `Magellan Internal Stats Reporter does not see a Magellan job name set in the environment.
        The build script must set MAGELLAN_JOB_NAME to use this feature.`);
    }
  }

  this.client = {
    timing: (metric, val, tags, cb) => {
      if (this.debugging) {
        this.logger("statsd:timing", metric, val, tags);
      }
      if (statsD) {
        statsD.timing(metric, val, tags, (err) => {
          if (err) {
            this.logger(err);
          }
          if (cb) {
            return cb(err);
          }
          return null;
        });
      }
    },
    increment: (metric, val, tags, cb) => {
      if (this.debugging) {
        this.logger("statsd:increment", metric, val, tags);
      }
      if (statsD) {
        statsD.increment(metric, val, tags, (err) => {
          if (err) {
            this.logger(err);
          }
          if (cb) {
            return cb(err);
          }
          return null;
        });
      }
    },
    gauge: (metric, val, tags, cb) => {
      if (this.debugging) {
        this.logger("statsd:gauge", metric, val, tags);
      }
      /* istanbul ignore else */
      if (statsD) {
        statsD.gauge(metric, val, tags, (err) => {
          if (err) {
            this.logger(err);
          }
          /* istanbul ignore else */
          if (cb) {
            return cb(err);
          }
        });
      }
    },
    close: (cb) => {
      /* istanbul ignore else */
      if (statsD) {
        this.logger("Sending close signal to statsd");
        statsD.close(cb);
        this.logger("Sent close signal to statsd");
      }
    }
  };

  this.srr = new SuiteRunResult();

  this.srr.on("testRunEnd", (testRun) => {
    this.client.increment(testRun.passed ? "passedtest" : "failedtest", 1, this._tags());

    const extraTags = {
      browser: testRun.environment.id,
      test: testRun.test.name,
      attemptNumber: testRun.attemptNumber
    };
    extraTags.passed = testRun.passed;

    this.client.timing("individualTestTime", testRun.timeElapsed, this._tags(extraTags));
  });

  this.srr.on("workerStatus", (worker, status) => {
    if (status === "end") {
      this.client.timing("timeToAcquire", worker.timeElapsed, this._tags());
    }
  });

  this.srr.on("magellanBusy", (time) => {
    this.client.timing("busyTime", time, this._tags());
  });

  this.srr.on("magellanIdle", (time) => {
    this.client.timing("idleTime", time, this._tags());
  });
};

Reporter.prototype.initialize = function (magellanGlobals) {
  const analytics = magellanGlobals.analytics;
  const self = this;
  const deferred = Q.defer();
  deferred.resolve();

  analytics.sync().forEach((message) => self.handleGlobalMessage(message));

  // listen to global emitter
  analytics.getEmitter().addListener("message", this.handleGlobalMessage.bind(this));

  return deferred.promise;
};

// listen to a testRun"s events on event emitter source.
Reporter.prototype.listenTo = function (testRun, test, source) {
  if (test && testRun) {
    // Every time a message is received regarding this test, we also get the test object
    // itself so that we"re able to reason about retries, worker index, etc.
    source.addListener("message", (event) => {
      this.handleTestRunMessage(testRun, test, event);
    });
  } else {
    source.addListener("message", this.handleGlobalMessage.bind(this));
  }
};

Reporter.prototype._tags = function (tagObject) {
  const tagObj = tagObject || {};
  tagObj.jobName = this.jobName;
  const out = [];
  for (const k of Object.keys(tagObj)) {
    out.push(`${k}:${tagObj[k]}`);
  }
  return out;
};

// handle a message from a test
Reporter.prototype.handleTestRunMessage = function (testRun, test, message) {
  this.srr.testRunMessage(testRun, test, message);

  if (this.log) {
    this._addToLog({
      type: "testRun",
      testRun,
      test,
      message
    });
  }
};

// handle a message from a global source
Reporter.prototype.handleGlobalMessage = function (message) {
  this.srr.globalMessage(message);

  if (!this.enabled) {
    return;
  }

  if (this.log) {
    this._addToLog({
      type: "global",
      message
    });
  }
};

Reporter.prototype._sendGroupedMetrics = function (gauge, baseName, subName, groupings, key) {
  for (const k in groupings) {
    const tags = {};
    tags[subName] = k;
    gauge(baseName, groupings[k][key], tags);
  }
};

Reporter.prototype._addToLog = function (data) {
  this.log.push(data);
  if (this.log.length > 500) {
    this._flushLog();
  }
};

Reporter.prototype._flushLog = function () {
  if (this.logDirectory && this.log) {
    const d = this.logDate;
    const fName = `${d.getMonth() + 1}_${d.getDate()}_${d.getFullYear()}` +
      `_${d.getHours()}_${d.getMinutes()}_${this.logIndex}.json`;
    const cName = `${this.logDirectory}/${fName}`;
    this.logger(`Writing ${this.log.length} events to ${cName} in ${process.cwd()}`);
    this.fs.writeFileSync(cName,
      JSON.stringify(this.log, null, 2));
    this.logIndex++;
    this.log = [];
  }
};

Reporter.prototype.flush = function () {
  try {
    return this._flush();
  } catch (e) {
    this.logger(e);
    throw e;
  }
};

Reporter.prototype._topAndBottomReport = function (title, report, f) {
  this.logger(`Top ${report.top.length} tests by least ${title}`);
  for (const test of report.top) {
    this.logger(`${test.name} - ${f(test)}ms`);
  }

  this.logger("");
  this.logger(`Top ${report.bottom.length} tests by most ${title}`);
  for (const test of report.bottom) {
    this.logger(`${test.name} - ${f(test)}ms`);
  }

  this.logger("");
  this.logger(`Average: ${report.average}ms, Stddev: ${report.stddev}`);
};

Reporter.prototype._reports = function () {
  const reports = this.srr.reports;

  this._topAndBottomReport("Total Time Elapsed", reports.timeElapsed, (test) => test.timeElapsed);
  this._topAndBottomReport("Time For Pass", reports.timeForPassed, (test) => test.timeForPassed);

  if (Object.keys(reports.byEnvironment).length > 0) {
    this.logger("Performance by environment");
    Object.keys(reports.byEnvironment).forEach((name) => {
      const env = reports.byEnvironment[name];
      const values = Object.keys(env).map((k) => `${k}: ${env[k]}`);
      this.logger(`${name} - ${values.join(", ")}`);
    });
  }
};

Reporter.prototype._flush = function () {
  const deferred = Q.defer();

  if (!this.enabled) {
    deferred.resolve();
    return deferred.promise;
  }

  this._flushLog();

  const flushQueue = [];
  const _timing = (key, val, tags) => {
    flushQueue.push((done) => {
      this.client.timing(key, val, this._tags(tags || {}), () => {
        done();
      });
    });
  };
  const _increment = (key, val, tags) => {
    flushQueue.push((done) => {
      this.client.increment(key, val, this._tags(tags || {}), () => {
        done();
      });
    });
  };
  const _gauge = (key, val, tags) => {
    flushQueue.push((done) => {
      this.client.gauge(key, val, this._tags(tags || {}), () => {
        done();
      });
    });
  };

  if (this.srr.totalIdleTime) {
    _timing("timeSpentIdle", this.srr.totalIdleTime);
  }

  if (this.srr.totalBusyTime) {
    _timing("timeSpentBusy", this.srr.totalBusyTime);
  }

  if (this.srr.passed > 0) {
    _timing("averageTimeSpentPassing", this.srr.timePassing / this.srr.passed);
  }

  if (this.srr.retried > 0) {
    _timing("averageTimeSpentRetrying", this.srr.timeRetrying / this.srr.retried);
  }

  if (this.srr.failed > 0) {
    _timing("averageTimeSpentFailing", this.srr.timeFailing / this.srr.failed);
  }

  // This number *should* always exist unless magellan itself actually crashes, in which
  // case we"ll probably never reach this flush().
  if (this.srr.failed > 0) {
    _timing("failingParallelTime", this.srr.totalTime);
  } else {
    _timing("passingParallelTime", this.srr.totalTime);
  }

  _timing("timeSpentFailing", this.srr.timeFailing);
  _timing("timeSpentPassing", this.srr.timePassing);
  _timing("timeSpentRetrying", this.srr.timeRetrying);
  _timing("serialTime", this.srr.timeFailing + this.srr.timePassing);
  _timing("parallelTime", this.srr.totalTime);
  _timing("timeSpentAcquiringWorkers", this.srr.satisfiedWorkersTime);
  _increment("satisfiedWorkerAcquisitions", this.srr.satisfiedWorkers.length);
  _increment("unsatisfiedWorkerAcquisitions", this.srr.unsatisfiedWorkers.length);

  this.logger("------------ Magellan Stats Reporter Gauges ---");

  const attemptTracker = { 1: 0, 2: 0, 3: 0 };

  for (const test of this.srr.tests) {
    if (test.passed) {
      for (const env in test.environments) {
        attemptTracker[test.environments[env].attempts.length]++;
      }
    }
  }

  _gauge("passingTests", this.srr.passed);
  _gauge("failedTests", this.srr.failed);

  const tbnr = this.srr.testsByNameReport;
  const tbbr = this.srr.testsByEnvironmentReport;

  this._sendGroupedMetrics(_gauge, "passingTestsByBrowser", "browser", tbbr, "passed");
  this._sendGroupedMetrics(_gauge, "passingTestsByTest", "test", tbnr, "passed");
  this._sendGroupedMetrics(_gauge, "failedTestsByBrowser", "browser", tbbr, "failed");
  this._sendGroupedMetrics(_gauge, "failedTestsByTest", "test", tbnr, "failed");
  this._sendGroupedMetrics(_gauge, "passedRetriesByBrowser", "browser", tbbr, "passedRetries");
  this._sendGroupedMetrics(_gauge, "passedRetriesByTest", "test", tbnr, "passedRetries");

  for (const test of this.srr.tests) {
    this.srr.setTags(test.name, this.getTags(test.name));
  }

  const smokeCount = this.srr.testsByTag("smoke").length;
  const p2Count = this.srr.tests.length - smokeCount;

  switch (buildType(argv.tags)) {
  case 1:
  case 2:
    this.logger(`   P2 Total: ${p2Count}`);
    _gauge("p2TestCount", p2Count);
  case 3:
    this.logger(`   P1 Total: ${smokeCount}`);
    _gauge("p1TestCount", smokeCount);
    break;
  default:
  }

  Object.keys(attemptTracker).forEach((t) => {
    const value = attemptTracker[t];
    this.logger(`  # of ${t} try: ${value}`);
    _gauge("attemptCount", value, {attempts: t});
  });

  this.logger(` Pass Total: ${this.srr.passed}`);
  this.logger(` Fail Total: ${this.srr.failed}`);

  this._reports();

  const d = new Date();
  flushQueue.push((done) => {
    this.client.close((err) => {
      if (err) {
        this.logger(err);
      }
      this.logger(`Waited ${new Date() - d}ms for close`);
      done();
    });
  });

  async.series(flushQueue, () => {
    deferred.resolve();
  });

  return deferred.promise;
};

module.exports = Reporter;
